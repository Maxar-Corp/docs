package main

import (
	"fmt"
	"os"
	"path/filepath"
	"github.com/gruntwork-io/docs/file"
	"github.com/gruntwork-io/docs/errors"
	"github.com/gruntwork-io/docs/logger"
	"github.com/gruntwork-io/docs/globs"
	"github.com/gruntwork-io/docs/nav"
	"github.com/gruntwork-io/docs/config"
	"github.com/gruntwork-io/docs/github"
	"io/ioutil"
)

func GenerateDocs(opts *Opts, envVars *EnvVars) error {
	// Create a temp folder where repo files will be downloaded
	tmpFolder, err := ioutil.TempDir("", "gruntwork-docs")
	if err != nil {
		return errors.WithStackTrace(err)
	}
	// TODO: Uncomment this when done doing dev
	//defer deleteAllFiles(tmpFolder)

	logger.Logger.Printf("Created temp folder where Gruntwork Packages will be downloaded\n")
	logger.Logger.Printf("Temp Folder = %s\n", tmpFolder)

	logger.Logger.Printf("* * * Fetching all Gruntwork Packages from GitHub into temp folder... * * *")
	if err = FetchAllPackageRepoFiles(opts, envVars, tmpFolder + "/packages"); err != nil {
		return errors.WithStackTrace(err)
	}
	logger.Logger.Printf("* * * All Gruntwork Packages have been downloaded and extracted! * * *")

	logger.Logger.Printf("* * * Copying global docs into temp folder... * * *")
	err = file.CopyFiles(opts.GlobalDocsPath, tmpFolder + "/global")
	if err != nil {
		return errors.WithStackTrace(err)
	}
	logger.Logger.Printf("* * * Global docs have been copied! * * *")

	logger.Logger.Printf("* * * Starting to process repo files into HTML. * * * ")
	if err = ProcessFiles(tmpFolder, opts); err != nil {
		return errors.WithStackTrace(err)
	}
	logger.Logger.Printf("* * * Repo files successfuly processed! * * * ")

	return nil
}

// Fetch all files from each of the package repos
func FetchAllPackageRepoFiles(opts *Opts, envVars *EnvVars, dstPath string) error {
	config, err := config.GetConfigFromJsonFile(opts.ConfigFilePath)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	for _, gPackage := range config.Packages {
		logger.Logger.Printf("Downloading %s/%s...\n", gPackage.GithubRepoOwner, gPackage.GithubRepoName)
		githubCommit := &github.GithubCommit{
			RepoOwner: gPackage.GithubRepoOwner,
			RepoName: gPackage.GithubRepoName,
			GitRef: gPackage.GitRef,
		}

		githubToken := envVars.GithubOauthToken
		err := githubCommit.Download(dstPath, githubToken)
		if err != nil {
			return errors.WithStackTrace(err)
		}
	}

	return nil
}

// Process the HTML files, static content files, and Gruntwork Package repo files into a nicely formatted HTML website
// which is output at opts.OutputPath
func ProcessFiles(inputPath string, opts *Opts) error {
	var err error

	config, err := config.GetConfigFromJsonFile(opts.ConfigFilePath)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	rootNavFolder := nav.NewRootFolder()

	// Walk all files, copy non-markdown files ("files") and load all markdown files ("pages") into a nav tree
	err = filepath.Walk(inputPath, func(fullInputPath string, info os.FileInfo, fileErr error) error {
		relInputPath, err := file.GetPathRelativeTo(fullInputPath, inputPath)
		if err != nil {
			return err
		} else if shouldSkipPath(relInputPath, inputPath, opts) {
			logger.Logger.Printf("Skipping path %s\n", relInputPath)
			return nil
		} else {
			file := nav.NewFile(relInputPath, fullInputPath)
			err := file.PopulateOutputPath(config)
			if err != nil {
				// TODO: Neither the Type Assertion nor the error return works as expected here. Error:
				// runtime: goroutine stack exceeds 1000000000-byte limit
				// fatal error: stack overflow
				// ...
				// github.com/gruntwork-io/docs/nav.FileInputPathDidNotMatchAnyRegEx.Error(0x32e6bd, 0x1, 0xc440200420, 0x6185a)
				//	/Users/josh/go/src/github.com/gruntwork-io/docs/nav/file.go:126 +0x6a fp=0xc4402003d8 sp=0xc440200370
				// github.com/gruntwork-io/docs/nav.(*FileInputPathDidNotMatchAnyRegEx).Error(0xc42ada6370, 0x357138, 0xc42ada5d40)
				// <autogenerated>:6 +0x5b fp=0xc440200418 sp=0xc4402003d8

				//if noMatchErr, ok := err.(nav.FileInputPathDidNotMatchAnyRegEx); ok {
				//	logger.Logger.Printf("WARNING: File %s did not match any RegEx while processing.\nFull Error: %s\n", fullInputPath, noMatchErr)
				//} else {
				//	return err
				//}
			}

			if file.IsFile() {
				if err = file.WriteToOutputPath(inputPath, opts.OutputPath); err != nil {
					return errors.WithStackTrace(err)
				}
			}

			if file.IsPage() {
				page := file.GetAsPage(rootNavFolder)
				if err = page.PopulateProperties(); err != nil {
					return errors.WithStackTrace(err)
				}

				if err = page.AddToNavTree(); err != nil {
					return errors.WithStackTrace(err)
				}
			}

			return nil
		}
	})
	if err != nil {
		return errors.WithStackTrace(err)
	}

	// Now that our nav tree is constructed, populate the page bodies
	err = rootNavFolder.PopulateChildrenPageBodyProperties(opts.OutputPath, config)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	// Generate HTML from the NavTree files
	err = rootNavFolder.WriteChildrenHtmlToOutputhPath(opts.HtmlFilesPath, rootNavFolder, opts.OutputPath, config)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	// Copy HTML assets into the output directory
	err = file.CopyFile(opts.HtmlFilesPath + "/index.html", opts.OutputPath + "/index.html")
	if err != nil {
		return errors.WithStackTrace(err)
	}

	err = file.CopyFiles(opts.HtmlFilesPath + "/css", opts.OutputPath + "/_assets/css")
	if err != nil {
		return errors.WithStackTrace(err)
	}

	err = file.CopyFiles(opts.HtmlFilesPath + "/img", opts.OutputPath + "/_assets/img")
	if err != nil {
		return errors.WithStackTrace(err)
	}

	err = file.CopyFiles(opts.HtmlFilesPath + "/favicons", opts.OutputPath + "/")
	if err != nil {
		return errors.WithStackTrace(err)
	}

	return nil
}

// Return true if this is a file or folder we should skip completely in the processing step.
// The "inputPath" refers to the path where all files were originally processed from (most likely a tmp folder)
func shouldSkipPath(path string, inputPath string, opts *Opts) bool {
	return path == inputPath || globs.MatchesGlobs(path, opts.Excludes)
}

func deleteAllFiles(path string) error {
	return os.RemoveAll(path)
}

// custom error types

type RegExReturnedUnexpectedNumberOfMatches string
func (regex RegExReturnedUnexpectedNumberOfMatches) Error() string {
	return fmt.Sprintf("The Regular Expression \"%s\" returned a different number of matches than we expected.\n", string(regex))
}